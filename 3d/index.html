<html><head><base href="https://www.unique-labyrinth-explorer.com/">
<title>3D Labyrinth Explorer</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
  canvas { display: block; }
  #menu {
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 10px;
    border-radius: 5px;
  }
  button {
    margin: 5px;
    padding: 5px 10px;
    background: #4CAF50;
    color: white;
    border: none;
    border-radius: 3px;
    cursor: pointer;
  }
  button:hover {
    background: #45a049;
  }
  #instructions {
    position: absolute;
    bottom: 10px;
    left: 10px;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 10px;
    border-radius: 5px;
  }
</style>
</head>
<body>
<div id="menu">
  <button id="generateBtn">Generate New Labyrinth</button>
  <button id="saveBtn">Save Labyrinth</button>
  <button id="loadBtn">Load Labyrinth</button>
  <button id="toggleCollisionBtn">Disable Collision</button>
  <input type="file" id="fileInput" style="display:none;">
</div>
<div id="instructions">
  <p>Click to start | WASD or Arrow Keys: Move | Mouse: Look | Shift: Run | Space: Jump | ESC: Release mouse</p>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
<script>
let scene, camera, renderer, controls;
let labyrinth, player;
const CELL_SIZE = 10;
const WALL_HEIGHT = 5;
const LABYRINTH_SIZE = 20;

let moveForward = false;
let moveBackward = false;
let moveLeft = false;
let moveRight = false;
let sprint = false;
let canJump = false;
let collisionEnabled = true;

let prevTime = performance.now();
const velocity = new THREE.Vector3();
const direction = new THREE.Vector3();

const WALK_SPEED = 150;
const RUN_SPEED = 300;
const JUMP_HEIGHT = 20;
const GRAVITY = 30;
const PLAYER_HEIGHT = 2;
const PLAYER_RADIUS = 0.5;
const COLLISION_MARGIN = 0.3; // New collision margin

function init() {
  scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x87CEEB, 0, 500);
  
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x87CEEB); // Sky blue color
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);

  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(50, 100, 50);
  light.castShadow = true;
  light.shadow.mapSize.width = 2048;
  light.shadow.mapSize.height = 2048;
  light.shadow.camera.near = 1;
  light.shadow.camera.far = 500;
  scene.add(light);

  const ambientLight = new THREE.AmbientLight(0x404040);
  scene.add(ambientLight);

  player = new THREE.Group();
  player.position.set(CELL_SIZE / 2, PLAYER_HEIGHT, CELL_SIZE / 2);
  scene.add(player);

  camera.position.set(0, 0, 0);
  player.add(camera);

  controls = new THREE.PointerLockControls(camera, document.body);

  scene.add(controls.getObject());

  const onKeyDown = function (event) {
    switch (event.code) {
      case 'ArrowUp':
      case 'KeyW':
        moveForward = true;
        break;
      case 'ArrowLeft':
      case 'KeyA':
        moveLeft = true;
        break;
      case 'ArrowDown':
      case 'KeyS':
        moveBackward = true;
        break;
      case 'ArrowRight':
      case 'KeyD':
        moveRight = true;
        break;
      case 'ShiftLeft':
      case 'ShiftRight':
        sprint = true;
        break;
      case 'Space':
        if (canJump) {
          velocity.y += JUMP_HEIGHT;
          canJump = false;
        }
        break;
    }
  };

  const onKeyUp = function (event) {
    switch (event.code) {
      case 'ArrowUp':
      case 'KeyW':
        moveForward = false;
        break;
      case 'ArrowLeft':
      case 'KeyA':
        moveLeft = false;
        break;
      case 'ArrowDown':
      case 'KeyS':
        moveBackward = false;
        break;
      case 'ArrowRight':
      case 'KeyD':
        moveRight = false;
        break;
      case 'ShiftLeft':
      case 'ShiftRight':
        sprint = false;
        break;
    }
  };

  document.addEventListener('keydown', onKeyDown);
  document.addEventListener('keyup', onKeyUp);

  document.addEventListener('click', function () {
    controls.lock();
  });

  controls.addEventListener('lock', function () {
    document.getElementById('instructions').style.display = 'none';
  });

  controls.addEventListener('unlock', function () {
    document.getElementById('instructions').style.display = 'block';
  });

  generateLabyrinth();
  animate();

  window.addEventListener('resize', onWindowResize, false);
  document.getElementById('generateBtn').addEventListener('click', generateLabyrinth);
  document.getElementById('saveBtn').addEventListener('click', saveLabyrinth);
  document.getElementById('loadBtn').addEventListener('click', () => document.getElementById('fileInput').click());
  document.getElementById('fileInput').addEventListener('change', loadLabyrinth);
  document.getElementById('toggleCollisionBtn').addEventListener('click', toggleCollision);
}

function generateLabyrinth() {
  if (labyrinth) {
    scene.remove(labyrinth);
  }
  labyrinth = new THREE.Group();
  scene.add(labyrinth);

  const matrix = generateMatrix();
  const wallGeometry = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
  const wallTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/brick_diffuse.jpg');
  wallTexture.wrapS = THREE.RepeatWrapping;
  wallTexture.wrapT = THREE.RepeatWrapping;
  wallTexture.repeat.set(1, 1);
  const wallMaterial = new THREE.MeshPhongMaterial({ map: wallTexture });

  for (let i = 0; i < LABYRINTH_SIZE; i++) {
    for (let j = 0; j < LABYRINTH_SIZE; j++) {
      if (matrix[i][j] === 1) {
        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
        wall.position.set(i * CELL_SIZE + CELL_SIZE / 2, WALL_HEIGHT / 2, j * CELL_SIZE + CELL_SIZE / 2);
        wall.castShadow = true;
        wall.receiveShadow = true;
        labyrinth.add(wall);
      }
    }
  }

  const floorGeometry = new THREE.PlaneGeometry(LABYRINTH_SIZE * CELL_SIZE, LABYRINTH_SIZE * CELL_SIZE);
  const floorTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg');
  floorTexture.wrapS = THREE.RepeatWrapping;
  floorTexture.wrapT = THREE.RepeatWrapping;
  floorTexture.repeat.set(LABYRINTH_SIZE, LABYRINTH_SIZE);
  const floorMaterial = new THREE.MeshPhongMaterial({ map: floorTexture });
  const floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.rotation.x = -Math.PI / 2;
  floor.position.set((LABYRINTH_SIZE * CELL_SIZE) / 2, 0, (LABYRINTH_SIZE * CELL_SIZE) / 2);
  floor.receiveShadow = true;
  labyrinth.add(floor);

  localStorage.setItem('labyrinth', JSON.stringify(matrix));

  // Reset player position
  player.position.set(CELL_SIZE / 2, PLAYER_HEIGHT, CELL_SIZE / 2);
  controls.getObject().position.set(CELL_SIZE / 2, PLAYER_HEIGHT, CELL_SIZE / 2);
  velocity.set(0, 0, 0);
}

function generateMatrix() {
  const matrix = Array(LABYRINTH_SIZE).fill().map(() => Array(LABYRINTH_SIZE).fill(1));
  const stack = [[1, 1]];
  
  while (stack.length > 0) {
    const [x, y] = stack.pop();
    matrix[x][y] = 0;

    const directions = [[0, -2], [2, 0], [0, 2], [-2, 0]].sort(() => Math.random() - 0.5);

    for (const [dx, dy] of directions) {
      const nx = x + dx, ny = y + dy;
      if (nx > 0 && nx < LABYRINTH_SIZE - 1 && ny > 0 && ny < LABYRINTH_SIZE - 1 && matrix[nx][ny] === 1) {
        matrix[x + dx/2][y + dy/2] = 0;
        stack.push([nx, ny]);
      }
    }
  }

  return matrix;
}

function saveLabyrinth() {
  const matrix = JSON.parse(localStorage.getItem('labyrinth'));
  const blob = new Blob([JSON.stringify(matrix)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'labyrinth.json';
  a.click();
  URL.revokeObjectURL(url);
}

function loadLabyrinth(event) {
  const file = event.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = function(e) {
      const matrix = JSON.parse(e.target.result);
      localStorage.setItem('labyrinth', JSON.stringify(matrix));
      generateLabyrinthFromMatrix(matrix);
    };
    reader.readAsText(file);
  }
}

function generateLabyrinthFromMatrix(matrix) {
  if (labyrinth) {
    scene.remove(labyrinth);
  }
  labyrinth = new THREE.Group();
  scene.add(labyrinth);

  const wallGeometry = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
  const wallTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/brick_diffuse.jpg');
  wallTexture.wrapS = THREE.RepeatWrapping;
  wallTexture.wrapT = THREE.RepeatWrapping;
  wallTexture.repeat.set(1, 1);
  const wallMaterial = new THREE.MeshPhongMaterial({ map: wallTexture });

  for (let i = 0; i < LABYRINTH_SIZE; i++) {
    for (let j = 0; j < LABYRINTH_SIZE; j++) {
      if (matrix[i][j] === 1) {
        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
        wall.position.set(i * CELL_SIZE + CELL_SIZE / 2, WALL_HEIGHT / 2, j * CELL_SIZE + CELL_SIZE / 2);
        wall.castShadow = true;
        wall.receiveShadow = true;
        labyrinth.add(wall);
      }
    }
  }

  const floorGeometry = new THREE.PlaneGeometry(LABYRINTH_SIZE * CELL_SIZE, LABYRINTH_SIZE * CELL_SIZE);
  const floorTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg');
  floorTexture.wrapS = THREE.RepeatWrapping;
  floorTexture.wrapT = THREE.RepeatWrapping;
  floorTexture.repeat.set(LABYRINTH_SIZE, LABYRINTH_SIZE);
  const floorMaterial = new THREE.MeshPhongMaterial({ map: floorTexture });
  const floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.rotation.x = -Math.PI / 2;
  floor.position.set((LABYRINTH_SIZE * CELL_SIZE) / 2, 0, (LABYRINTH_SIZE * CELL_SIZE) / 2);
  floor.receiveShadow = true;
  labyrinth.add(floor);

  // Reset player position
  player.position.set(CELL_SIZE / 2, PLAYER_HEIGHT, CELL_SIZE / 2);
  controls.getObject().position.set(CELL_SIZE / 2, PLAYER_HEIGHT, CELL_SIZE / 2);
  velocity.set(0, 0, 0);
}

function animate() {
  requestAnimationFrame(animate);

  const time = performance.now();
  const delta = (time - prevTime) / 1000;

  velocity.x -= velocity.x * 10.0 * delta;
  velocity.z -= velocity.z * 10.0 * delta;

  velocity.y -= GRAVITY * delta; // Apply gravity

  direction.z = Number(moveForward) - Number(moveBackward);
  direction.x = Number(moveRight) - Number(moveLeft);
  direction.normalize();

  const speed = sprint ? RUN_SPEED : WALK_SPEED;

  if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
  if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;

  const oldPosition = controls.getObject().position.clone();
  controls.moveRight(-velocity.x * delta);
  controls.moveForward(-velocity.z * delta);

  controls.getObject().position.y += velocity.y * delta;

  // Collision detection
  if (collisionEnabled) {
    const matrix = JSON.parse(localStorage.getItem('labyrinth'));
    const playerX = Math.floor(controls.getObject().position.x / CELL_SIZE);
    const playerZ = Math.floor(controls.getObject().position.z / CELL_SIZE);

    if (playerX >= 0 && playerX < LABYRINTH_SIZE && playerZ >= 0 && playerZ < LABYRINTH_SIZE) {
      const checkCollision = (x, z) => {
        if (x >= 0 && x < LABYRINTH_SIZE && z >= 0 && z < LABYRINTH_SIZE && matrix[x][z] === 1) {
          const wallMinX = x * CELL_SIZE;
          const wallMaxX = (x + 1) * CELL_SIZE;
          const wallMinZ = z * CELL_SIZE;
          const wallMaxZ = (z + 1) * CELL_SIZE;

          const playerMinX = controls.getObject().position.x - PLAYER_RADIUS - COLLISION_MARGIN;
          const playerMaxX = controls.getObject().position.x + PLAYER_RADIUS + COLLISION_MARGIN;
          const playerMinZ = controls.getObject().position.z - PLAYER_RADIUS - COLLISION_MARGIN;
          const playerMaxZ = controls.getObject().position.z + PLAYER_RADIUS + COLLISION_MARGIN;

          if (playerMaxX > wallMinX && playerMinX < wallMaxX &&
              playerMaxZ > wallMinZ && playerMinZ < wallMaxZ) {
            return true;
          }
        }
        return false;
      };

      // Check current cell and neighboring cells
      if (checkCollision(playerX, playerZ) ||
          checkCollision(playerX - 1, playerZ) ||
          checkCollision(playerX + 1, playerZ) ||
          checkCollision(playerX, playerZ - 1) ||
          checkCollision(playerX, playerZ + 1)) {
        // Collision detected, move the player back
        controls.getObject().position.copy(oldPosition);
        velocity.x = 0;
        velocity.z = 0;
      }
    }
  }

  if (controls.getObject().position.y < PLAYER_HEIGHT) {
    velocity.y = 0;
    controls.getObject().position.y = PLAYER_HEIGHT;
    canJump = true;
  }

  prevTime = time;

  renderer.render(scene, camera);
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function toggleCollision() {
  collisionEnabled = !collisionEnabled;
  const button = document.getElementById('toggleCollisionBtn');
  button.textContent = collisionEnabled ? 'Disable Collision' : 'Enable Collision';
  button.style.background = collisionEnabled ? '#ff4136' : '#4CAF50';
}

init();
</script>
</body>
</html>